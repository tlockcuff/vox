name: Build & Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Release tag (e.g. v1.0.0)'
        required: true
        default: 'v1.0.0'

permissions:
  contents: write

jobs:
  build:
    runs-on: macos-14
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "VERSION=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
            echo "SHORT_VERSION=$(echo ${{ github.event.inputs.tag }} | sed 's/^v//')" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
            echo "SHORT_VERSION=$(echo ${GITHUB_REF#refs/tags/} | sed 's/^v//')" >> $GITHUB_OUTPUT
          fi

      - name: Import signing certificate
        env:
          DEVELOPER_ID_CERT_BASE64: ${{ secrets.DEVELOPER_ID_CERT_BASE64 }}
          DEVELOPER_ID_CERT_PASSWORD: ${{ secrets.DEVELOPER_ID_CERT_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -hex 16)

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          CERT_PATH=$RUNNER_TEMP/cert.p12
          echo "$DEVELOPER_ID_CERT_BASE64" | base64 --decode > "$CERT_PATH"
          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$DEVELOPER_ID_CERT_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Add to search list
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

          # Find signing identity
          IDENTITY=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          if [[ -z "$IDENTITY" ]]; then
            echo "‚ùå No Developer ID Application identity found"
            security find-identity -v -p codesigning "$KEYCHAIN_PATH"
            exit 1
          fi
          echo "SIGNING_IDENTITY=$IDENTITY" >> $GITHUB_ENV
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          echo "‚úÖ Signing identity: $IDENTITY"

      - name: Generate app icon
        run: bash scripts/generate-icon.sh VoxApp/Sources/Assets.xcassets/AppIcon.appiconset

      - name: Build Vox
        run: |
          cd VoxApp
          swift build -c release
          # Find Sparkle framework location from SPM
          SPARKLE_FRAMEWORK=$(find .build -name "Sparkle.framework" -type d | head -1)
          echo "SPARKLE_FRAMEWORK=${SPARKLE_FRAMEWORK}" >> $GITHUB_ENV
          echo "Sparkle framework at: ${SPARKLE_FRAMEWORK}"
          cd ..

      - name: Download sherpa-onnx
        run: |
          SHERPA_VERSION="v1.12.25"
          curl -sL "https://github.com/k2-fsa/sherpa-onnx/releases/download/${SHERPA_VERSION}/sherpa-onnx-${SHERPA_VERSION}-osx-universal2-shared.tar.bz2" -o sherpa.tar.bz2
          tar xf sherpa.tar.bz2
          SHERPA_DIR=$(ls -d sherpa-onnx-*)
          mkdir -p staging/bin staging/lib
          cp "${SHERPA_DIR}/bin/sherpa-onnx-offline-tts" staging/bin/
          cp ${SHERPA_DIR}/lib/*.dylib staging/lib/
          rm -rf sherpa.tar.bz2 "${SHERPA_DIR}"

      - name: Download Kokoro model
        run: |
          curl -sL "https://github.com/k2-fsa/sherpa-onnx/releases/download/tts-models/kokoro-en-v0_19.tar.bz2" -o kokoro.tar.bz2
          tar xf kokoro.tar.bz2
          mv kokoro-en-v0_19 staging/
          rm kokoro.tar.bz2

      - name: Create .app bundle
        env:
          SPARKLE_ED_PUBLIC_KEY: ${{ secrets.SPARKLE_ED_PUBLIC_KEY }}
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          SHORT_VERSION="${{ steps.version.outputs.SHORT_VERSION }}"

          APP="Vox.app"
          CONTENTS="${APP}/Contents"
          MACOS="${CONTENTS}/MacOS"
          FRAMEWORKS="${CONTENTS}/Frameworks"
          RESOURCES="${CONTENTS}/Resources"

          mkdir -p "${MACOS}" "${FRAMEWORKS}" "${RESOURCES}"

          # Main executable
          cp VoxApp/.build/release/Vox "${MACOS}/Vox"

          # TTS engine + dylibs in Frameworks
          cp staging/bin/sherpa-onnx-offline-tts "${FRAMEWORKS}/"
          cp staging/lib/*.dylib "${FRAMEWORKS}/"

          # Sparkle framework
          if [[ -n "${SPARKLE_FRAMEWORK:-}" && -d "${SPARKLE_FRAMEWORK}" ]]; then
            cp -R "${SPARKLE_FRAMEWORK}" "${FRAMEWORKS}/"
            echo "‚úÖ Sparkle.framework embedded"
          else
            # Fallback: find in VoxApp build dir
            SPARKLE_FW=$(find VoxApp/.build -name "Sparkle.framework" -type d 2>/dev/null | head -1)
            if [[ -n "$SPARKLE_FW" ]]; then
              cp -R "$SPARKLE_FW" "${FRAMEWORKS}/"
              echo "‚úÖ Sparkle.framework embedded (fallback)"
            else
              echo "‚ö†Ô∏è Sparkle.framework not found ‚Äî auto-update will not work"
            fi
          fi

          # Model NOT bundled in .app (too large for notarization)
          # App downloads it on first launch to ~/Library/Application Support/Vox/

          # App icon
          ICONSET="${RESOURCES}/AppIcon.iconset"
          mkdir -p "${ICONSET}"
          ICON_SRC="VoxApp/Sources/Assets.xcassets/AppIcon.appiconset"
          cp "${ICON_SRC}/icon_16.png" "${ICONSET}/icon_16x16.png"
          cp "${ICON_SRC}/icon_32.png" "${ICONSET}/icon_16x16@2x.png"
          cp "${ICON_SRC}/icon_32.png" "${ICONSET}/icon_32x32.png"
          cp "${ICON_SRC}/icon_64.png" "${ICONSET}/icon_32x32@2x.png"
          cp "${ICON_SRC}/icon_128.png" "${ICONSET}/icon_128x128.png"
          cp "${ICON_SRC}/icon_256.png" "${ICONSET}/icon_128x128@2x.png"
          cp "${ICON_SRC}/icon_256.png" "${ICONSET}/icon_256x256.png"
          cp "${ICON_SRC}/icon_512.png" "${ICONSET}/icon_256x256@2x.png"
          cp "${ICON_SRC}/icon_512.png" "${ICONSET}/icon_512x512.png"
          cp "${ICON_SRC}/icon_1024.png" "${ICONSET}/icon_512x512@2x.png"
          iconutil -c icns "${ICONSET}" -o "${RESOURCES}/AppIcon.icns"
          rm -rf "${ICONSET}"

          # Fix dylib rpaths so DYLD_LIBRARY_PATH isn't needed
          cd "${FRAMEWORKS}"
          for dylib in *.dylib; do
            install_name_tool -id "@loader_path/${dylib}" "${dylib}" 2>/dev/null || true
          done
          # Fix all cross-references between dylibs
          for binary in sherpa-onnx-offline-tts *.dylib; do
            for dylib in *.dylib; do
              install_name_tool -change "@rpath/${dylib}" "@loader_path/${dylib}" "${binary}" 2>/dev/null || true
              install_name_tool -change "/usr/local/lib/${dylib}" "@loader_path/${dylib}" "${binary}" 2>/dev/null || true
              install_name_tool -change "${dylib}" "@loader_path/${dylib}" "${binary}" 2>/dev/null || true
            done
          done
          cd -

          # Info.plist
          cat > "${CONTENTS}/Info.plist" <<'          PLIST'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleName</key>
              <string>Vox</string>
              <key>CFBundleDisplayName</key>
              <string>Vox</string>
              <key>CFBundleIdentifier</key>
              <string>com.tlockcuff.vox</string>
              <key>CFBundleExecutable</key>
              <string>Vox</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleIconFile</key>
              <string>AppIcon</string>
              <key>LSMinimumSystemVersion</key>
              <string>13.0</string>
              <key>LSUIElement</key>
              <true/>
              <key>NSHighResolutionCapable</key>
              <true/>
              <key>SUFeedURL</key>
              <string>SPARKLE_FEED_URL_PLACEHOLDER</string>
              <key>SUPublicEDKey</key>
              <string>SPARKLE_PUBLIC_KEY_PLACEHOLDER</string>
          </dict>
          </plist>
          PLIST
          sed -i '' "s|</dict>|    <key>CFBundleVersion</key><string>${SHORT_VERSION}</string><key>CFBundleShortVersionString</key><string>${SHORT_VERSION}</string></dict>|" "${CONTENTS}/Info.plist"
          sed -i '' "s|SPARKLE_FEED_URL_PLACEHOLDER|https://raw.githubusercontent.com/tlockcuff/vox/main/appcast.xml|" "${CONTENTS}/Info.plist"
          sed -i '' "s|SPARKLE_PUBLIC_KEY_PLACEHOLDER|${SPARKLE_ED_PUBLIC_KEY}|" "${CONTENTS}/Info.plist"

          chmod +x "${MACOS}/Vox" "${FRAMEWORKS}/sherpa-onnx-offline-tts"

      - name: Codesign .app bundle
        run: |
          APP="Vox.app"
          FRAMEWORKS="${APP}/Contents/Frameworks"
          ENTITLEMENTS="scripts/entitlements.plist"

          # Sign Sparkle framework (inside out)
          if [[ -d "${FRAMEWORKS}/Sparkle.framework" ]]; then
            codesign --force --options runtime --timestamp \
              --sign "$SIGNING_IDENTITY" "${FRAMEWORKS}/Sparkle.framework/Versions/B/XPCServices/"*.xpc/Contents/MacOS/* 2>/dev/null || true
            codesign --force --options runtime --timestamp \
              --sign "$SIGNING_IDENTITY" "${FRAMEWORKS}/Sparkle.framework/Versions/B/XPCServices/"*.xpc 2>/dev/null || true
            codesign --force --options runtime --timestamp \
              --sign "$SIGNING_IDENTITY" "${FRAMEWORKS}/Sparkle.framework/Versions/B/Autoupdate" 2>/dev/null || true
            codesign --force --options runtime --timestamp \
              --sign "$SIGNING_IDENTITY" "${FRAMEWORKS}/Sparkle.framework/Versions/B/Updater.app" 2>/dev/null || true
            codesign --force --options runtime --timestamp \
              --sign "$SIGNING_IDENTITY" "${FRAMEWORKS}/Sparkle.framework"
            echo "‚úÖ Sparkle.framework signed"
          fi

          # Sign dylibs first (inside out) ‚Äî with entitlements for ONNX Runtime JIT
          for dylib in "${FRAMEWORKS}"/*.dylib; do
            codesign --force --options runtime --timestamp \
              --entitlements "$ENTITLEMENTS" \
              --sign "$SIGNING_IDENTITY" "$dylib"
          done

          # Sign TTS binary with entitlements
          codesign --force --options runtime --timestamp \
            --entitlements "$ENTITLEMENTS" \
            --sign "$SIGNING_IDENTITY" "${FRAMEWORKS}/sherpa-onnx-offline-tts"

          # Sign main executable with entitlements
          codesign --force --options runtime --timestamp \
            --entitlements "$ENTITLEMENTS" \
            --sign "$SIGNING_IDENTITY" "${APP}/Contents/MacOS/Vox"

          # Sign the whole .app bundle
          codesign --force --deep --options runtime --timestamp \
            --entitlements "$ENTITLEMENTS" \
            --sign "$SIGNING_IDENTITY" "$APP"

          # Verify
          codesign --verify --deep --strict --verbose=2 "$APP"
          echo "‚úÖ Codesigning verified"

      - name: Notarize .app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Create a zip for notarization
          ditto -c -k --keepParent Vox.app Vox-notarize.zip
          echo "üì§ Zip size: $(du -sh Vox-notarize.zip | cut -f1)"

          # Submit and wait (5 min timeout ‚Äî if Apple is slow, we ship signed-only)
          echo "üì§ Submitting for notarization..."
          if xcrun notarytool submit Vox-notarize.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait --timeout 300; then
            echo "üìé Stapling notarization ticket..."
            xcrun stapler staple Vox.app
            echo "‚úÖ Notarization complete"
          else
            echo "‚ö†Ô∏è Notarization did not complete in time ‚Äî shipping signed-only"
            echo "   (Users will see a one-time 'Open Anyway' prompt in System Settings)"
          fi
          rm -f Vox-notarize.zip

      - name: Create DMG
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          DMG_NAME="Vox-${VERSION}.dmg"

          # Free up disk space
          rm -f Vox-notarize.zip
          df -h . | tail -1
          echo "---"

          mkdir -p dmg-staging
          cp -r Vox.app dmg-staging/
          ln -s /Applications dmg-staging/Applications

          hdiutil create -volname "Vox" -srcfolder dmg-staging -ov -format UDZO "${DMG_NAME}"
          rm -rf dmg-staging

          # Sign the DMG
          codesign --force --timestamp --sign "$SIGNING_IDENTITY" "${DMG_NAME}"

          # Notarize DMG (non-blocking ‚Äî app may already be notarized)
          echo "üì§ Notarizing DMG..."
          if xcrun notarytool submit "${DMG_NAME}" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait --timeout 300; then
            xcrun stapler staple "${DMG_NAME}" || true
            echo "‚úÖ DMG notarized"
          else
            echo "‚ö†Ô∏è DMG notarization skipped ‚Äî shipping signed-only"
          fi

      - name: Cleanup keychain
        if: always()
        run: |
          if [[ -n "${KEYCHAIN_PATH:-}" ]]; then
            security delete-keychain "$KEYCHAIN_PATH" 2>/dev/null || true
          fi

      - name: Generate appcast
        env:
          SPARKLE_ED_PRIVATE_KEY: ${{ secrets.SPARKLE_ED_PRIVATE_KEY }}
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          DMG_NAME="Vox-${VERSION}.dmg"
          DMG_URL="https://github.com/tlockcuff/vox/releases/download/${VERSION}/${DMG_NAME}"
          DMG_SIZE=$(stat -f%z "${DMG_NAME}")
          PUB_DATE=$(date -u "+%a, %d %b %Y %H:%M:%S +0000")
          SHORT_VERSION="${{ steps.version.outputs.SHORT_VERSION }}"

          # Sign the DMG with Sparkle EdDSA key
          if [[ -n "${SPARKLE_ED_PRIVATE_KEY:-}" ]]; then
            # Find sign_update tool
            SIGN_TOOL=$(find VoxApp/.build -name "sign_update" -type f 2>/dev/null | head -1)
            if [[ -z "$SIGN_TOOL" ]]; then
              # Download Sparkle tools
              curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/2.7.5/Sparkle-2.7.5.tar.xz" -o /tmp/sparkle.tar.xz
              mkdir -p /tmp/sparkle-tools && tar xf /tmp/sparkle.tar.xz -C /tmp/sparkle-tools
              SIGN_TOOL="/tmp/sparkle-tools/bin/sign_update"
            fi

            if [[ -f "$SIGN_TOOL" ]]; then
              chmod +x "$SIGN_TOOL"
              SIGNATURE=$(echo "$SPARKLE_ED_PRIVATE_KEY" | "$SIGN_TOOL" "${DMG_NAME}" --ed-key-file - 2>/dev/null | grep 'edSignature' | sed 's/.*edSignature="\([^"]*\)".*/\1/')
              echo "EdDSA signature: ${SIGNATURE:0:20}..."
            fi
          fi

          # Generate appcast.xml (save to /tmp so git stash doesn't eat it)
          cat > /tmp/appcast.xml << APPCAST
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>Vox Updates</title>
              <link>https://github.com/tlockcuff/vox</link>
              <language>en</language>
              <item>
                <title>Vox ${SHORT_VERSION}</title>
                <pubDate>${PUB_DATE}</pubDate>
                <sparkle:version>${SHORT_VERSION}</sparkle:version>
                <sparkle:shortVersionString>${SHORT_VERSION}</sparkle:shortVersionString>
                <sparkle:minimumSystemVersion>13.0</sparkle:minimumSystemVersion>
                <enclosure url="${DMG_URL}"
                  sparkle:edSignature="${SIGNATURE:-}"
                  length="${DMG_SIZE}"
                  type="application/octet-stream" />
              </item>
            </channel>
          </rss>
          APPCAST
          echo "‚úÖ Appcast generated"
          cat /tmp/appcast.xml

      - name: Commit appcast
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git stash --include-untracked || true
          git fetch origin main
          git checkout -f main
          cp /tmp/appcast.xml ./appcast.xml
          git add appcast.xml
          git diff --cached --quiet || git commit -m "Update appcast for ${{ steps.version.outputs.VERSION }}"
          git push origin main || echo "‚ö†Ô∏è Could not push appcast (non-fatal)"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.VERSION }}
          name: Vox ${{ steps.version.outputs.VERSION }}
          body: |
            ## Vox ${{ steps.version.outputs.VERSION }}

            **Highlight ‚Üí Right-Click ‚Üí Speak** with natural AI voices on macOS.

            ### Installation
            1. Download `Vox-${{ steps.version.outputs.VERSION }}.dmg`
            2. Open the DMG
            3. Drag **Vox** to **Applications**
            4. Launch Vox ‚Äî that's it! ‚ú®

            ### Features
            - üó£Ô∏è Natural AI voices (Kokoro TTS, 11 speakers)
            - üéµ Animated waveform visualizer
            - ‚è±Ô∏è ETA countdown
            - ‚èØÔ∏è Play/pause/stop controls in menu bar
            - üéöÔ∏è Speed control (0.5x - 2.0x)
            - üßπ Smart text cleanup (strips URLs, markdown, HTML)
            - üîÑ Built-in update checker
            - ‚úÖ Signed & notarized ‚Äî no Gatekeeper warnings
          files: |
            Vox-${{ steps.version.outputs.VERSION }}.dmg
          draft: false
          prerelease: false
